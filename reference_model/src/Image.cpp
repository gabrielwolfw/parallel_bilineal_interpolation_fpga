#include "Image.h"
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <algorithm>

Image::Image() : width(0), height(0) {}

Image::Image(uint32_t w, uint32_t h) : width(w), height(h) {
    pixels.resize(w * h, 0);
}

bool Image::load(const std::string& filename) {
    std::ifstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        return false;
    }

    std::string magic;
    file >> magic;
    
    // Soportar tanto PGM ASCII (P2) como PGM binario (P5)
    if (magic != "P2" && magic != "P5") {
        return false;
    }
    
    bool isBinary = (magic == "P5");
    
    // Ignorar comentarios
    std::string line;
    std::getline(file, line); // Consumir resto de línea del magic number
    
    while (file.peek() == '#') {
        std::getline(file, line);
    }
    
    // Leer dimensiones
    file >> width >> height;
    
    // Leer valor máximo
    int maxVal;
    file >> maxVal;
    
    if (maxVal != 255) {
        // Solo soportamos 8 bits por pixel
        return false;
    }
    
    pixels.resize(width * height);
    
    if (isBinary) {
        // PGM binario (P5)
        file.get(); // Consumir el newline después del maxval
        file.read(reinterpret_cast<char*>(pixels.data()), width * height);
    } else {
        // PGM ASCII (P2)
        for (uint32_t i = 0; i < width * height; i++) {
            int pixel;
            file >> pixel;
            pixels[i] = static_cast<uint8_t>(pixel);
        }
    }
    
    file.close();
    return true;
}

bool Image::save(const std::string& filename) const {
    std::ofstream file(filename, std::ios::binary);
    if (!file.is_open()) {
        return false;
    }

    // Escribir header PGM binario (P5)
    file << "P5\n";
    file << "# Generated by Bilinear Interpolator\n";
    file << width << " " << height << "\n";
    file << "255\n";
    
    // Escribir datos binarios
    file.write(reinterpret_cast<const char*>(pixels.data()), width * height);
    
    file.close();
    return true;
}

uint8_t Image::getPixel(uint32_t x, uint32_t y) const {
    if (x >= width || y >= height) {
        return 0;
    }
    return pixels[y * width + x];
}

void Image::setPixel(uint32_t x, uint32_t y, uint8_t value) {
    if (x < width && y < height) {
        pixels[y * width + x] = value;
    }
}
