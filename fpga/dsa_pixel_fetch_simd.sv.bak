//============================================================
// dsa_pixel_fetch_simd.sv
// Fetch optimizado para modo SIMD (N píxeles/ciclo)
// Estrategia: Fetch secuencial rápido de N grupos de píxeles
//============================================================

module dsa_pixel_fetch_simd #(
    parameter ADDR_WIDTH = 18,
    parameter IMG_WIDTH  = 512,
    parameter SIMD_WIDTH = 4
)(
    input  logic                    clk,
    input  logic                    rst,

    // Control
    input  logic                    req_valid,
    input  logic [15:0]             base_x,         // X inicial del grupo SIMD
    input  logic [15:0]             base_y,         // Y del grupo SIMD
    input  logic [7:0]              scale_factor,   // Para calcular coordenadas
    input  logic [ADDR_WIDTH-1:0]   img_base_addr,

    // Interfaz memoria
    output logic                    mem_read_en,
    output logic [ADDR_WIDTH-1:0]   mem_addr,
    input  logic [7:0]              mem_data,

    // Salidas SIMD (arrays)
    output logic                    fetch_valid,
    output logic [7:0]              p00 [0:SIMD_WIDTH-1],
    output logic [7:0]              p01 [0:SIMD_WIDTH-1],
    output logic [7:0]              p10 [0:SIMD_WIDTH-1],
    output logic [7:0]              p11 [0:SIMD_WIDTH-1],
    output logic [15:0]             a   [0:SIMD_WIDTH-1],
    output logic [15:0]             b   [0:SIMD_WIDTH-1],
    output logic                    busy
);

    //========================================================
    // Estados - Fetch de N grupos de 4 píxeles
    //========================================================
    typedef enum logic [3:0] {
        ST_IDLE      = 4'd0,
        ST_CALC_COORD = 4'd1,   // Calcular coordenadas para píxel actual
        ST_FETCH_P00 = 4'd2,
        ST_FETCH_P01 = 4'd3,
        ST_FETCH_P10 = 4'd4,
        ST_FETCH_P11 = 4'd5,
        ST_NEXT_PIXEL = 4'd6,    // Incrementar índice SIMD
        ST_DONE      = 4'd7
    } state_t;

    state_t state, next_state;

    //========================================================
    // Registros internos
    //========================================================
    logic [2:0]  simd_index;        // Índice actual dentro del grupo SIMD
    logic [15:0] current_x;         // X actual en imagen de salida
    
    // Coordenadas calculadas para píxel actual
    logic [25:0] src_x_fixed, src_y_fixed;
    logic [15:0] src_x_int, src_y_int;
    logic [15:0] frac_x, frac_y;
    
    // Direcciones precalculadas
    logic [ADDR_WIDTH-1:0] row0_base, row1_base;
    
    // Buffer temporal para el fetch actual
    logic [7:0] temp_p00, temp_p01, temp_p10;
    
    // Contador de fetch (para pipeline dentro de cada píxel)
    logic [1:0] fetch_step;

    //========================================================
    // Cálculo de coordenadas fuente
    //========================================================
    logic [25:0] inv_scale_fixed;
    
    always_comb begin
        // Calcular 1/scale_factor
        if (scale_factor != 0)
            inv_scale_fixed = (26'd65536 / scale_factor);
        else
            inv_scale_fixed = 26'd65536;
        
        // Mapear coordenadas de salida a entrada
        src_x_fixed = current_x * inv_scale_fixed;
        src_y_fixed = base_y * inv_scale_fixed;
        
        // Separar parte entera y fraccionaria
        src_x_int = src_x_fixed[25:16];
        src_y_int = src_y_fixed[25:16];
        frac_x    = src_x_fixed[15:0];
        frac_y    = src_y_fixed[15:0];
        
        // Bases de filas
        row0_base = img_base_addr + (src_y_int * IMG_WIDTH);
        row1_base = img_base_addr + ((src_y_int + 1) * IMG_WIDTH);
    end

    //========================================================
    // FSM - Transiciones
    //========================================================
    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= ST_IDLE;
            simd_index <= 0;
            current_x <= 0;
            fetch_step <= 0;
        end else begin
            state <= next_state;
            
            case (state)
                ST_IDLE: begin
                    if (req_valid) begin
                        simd_index <= 0;
                        current_x <= base_x;
                        fetch_step <= 0;
                    end
                end
                
                ST_CALC_COORD: begin
                    fetch_step <= 0;
                end
                
                ST_FETCH_P00, ST_FETCH_P01, ST_FETCH_P10, ST_FETCH_P11: begin
                    if (fetch_step == 0)
                        fetch_step <= 1;
                    else
                        fetch_step <= 0;
                end
                
                ST_NEXT_PIXEL: begin
                    if (simd_index < SIMD_WIDTH - 1) begin
                        simd_index <= simd_index + 1;
                        current_x <= current_x + 1;
                    end
                end
            endcase
        end
    end

    always_comb begin
        next_state = state;
        
        case (state)
            ST_IDLE: begin
                if (req_valid)
                    next_state = ST_CALC_COORD;
            end
            
            ST_CALC_COORD: begin
                next_state = ST_FETCH_P00;
            end
            
            ST_FETCH_P00: begin
                if (fetch_step == 1)
                    next_state = ST_FETCH_P01;
            end
            
            ST_FETCH_P01: begin
                if (fetch_step == 1)
                    next_state = ST_FETCH_P10;
            end
            
            ST_FETCH_P10: begin
                if (fetch_step == 1)
                    next_state = ST_FETCH_P11;
            end
            
            ST_FETCH_P11: begin
                if (fetch_step == 1)
                    next_state = ST_NEXT_PIXEL;
            end
            
            ST_NEXT_PIXEL: begin
                if (simd_index < SIMD_WIDTH - 1)
                    next_state = ST_CALC_COORD;
                else
                    next_state = ST_DONE;
            end
            
            ST_DONE: begin
                next_state = ST_IDLE;
            end
            
            default: next_state = ST_IDLE;
        endcase
    end

    //========================================================
    // Control de memoria y captura
    //========================================================
    always_ff @(posedge clk or posedge rst) begin
        if (rst) begin
            mem_read_en <= 1'b0;
            mem_addr <= '0;
            temp_p00 <= '0;
            temp_p01 <= '0;
            temp_p10 <= '0;
            
            for (int i = 0; i < SIMD_WIDTH; i++) begin
                p00[i] <= '0;
                p01[i] <= '0;
                p10[i] <= '0;
                p11[i] <= '0;
                a[i]   <= '0;
                b[i]   <= '0;
            end
        end else begin
            mem_read_en <= 1'b0;
            
            case (state)
                ST_FETCH_P00: begin
                    if (fetch_step == 0) begin
                        mem_addr <= row0_base + src_x_int;
                        mem_read_en <= 1'b1;
                    end else begin
                        temp_p00 <= mem_data;
                    end
                end
                
                ST_FETCH_P01: begin
                    if (fetch_step == 0) begin
                        mem_addr <= row0_base + src_x_int + 1;
                        mem_read_en <= 1'b1;
                    end else begin
                        temp_p01 <= mem_data;
                    end
                end
                
                ST_FETCH_P10: begin
                    if (fetch_step == 0) begin
                        mem_addr <= row1_base + src_x_int;
                        mem_read_en <= 1'b1;
                    end else begin
                        temp_p10 <= mem_data;
                    end
                end
                
                ST_FETCH_P11: begin
                    if (fetch_step == 0) begin
                        mem_addr <= row1_base + src_x_int + 1;
                        mem_read_en <= 1'b1;
                    end else begin
                        // Capturar p11 y guardar todo el grupo
                        p00[simd_index] <= temp_p00;
                        p01[simd_index] <= temp_p01;
                        p10[simd_index] <= temp_p10;
                        p11[simd_index] <= mem_data;
                        a[simd_index]   <= frac_x[15:8];
                        b[simd_index]   <= frac_y[15:8];
                    end
                end
            endcase
        end
    end

    //========================================================
    // Señales de salida
    //========================================================
    assign fetch_valid = (state == ST_DONE);
    assign busy        = (state != ST_IDLE);

endmodule